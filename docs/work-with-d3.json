{"markdown":"# Work With D3\n\n- <a href=\"#d3-cloud\">d3-cloud</a>\n- <a href=\"#d3-force\">d3-force</a>\n- <a href=\"#d3-hierarchy\">d3-hierarchy</a>\n- <a href=\"#d3-geo\">d3-geo</a>\n\n## d3-cloud\n\n```js | dom\n(async () => {\n  const response = await fetch(\n    \"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"\n  );\n  const data = await response.json();\n  const words = data.flatMap((d) =>\n    d.words.map(({ weight, word }) => ({\n      value: weight,\n      text: word,\n      name: d.name,\n    }))\n  );\n  const width = 640;\n  const height = 480;\n  const computedWords = await new Promise((resolve) =>\n    d3.layout\n      .cloud()\n      .size([width, height])\n      .words(words)\n      .padding(2)\n      .rotate(() => ~~(Math.random() * 2) * 90)\n      .fontSize((d) => d.value * 2)\n      .on(\"end\", resolve)\n      .start()\n  );\n\n  return sp.plot({\n    data: computedWords,\n    type: \"text\",\n    width,\n    height,\n    paddingTop: 0,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    guides: {\n      x: { display: false },\n      y: { display: false },\n      color: { display: false },\n    },\n    scales: {\n      fontSize: { type: \"identity\" },\n      rotate: { type: \"identity\" },\n      y: { range: [0, 1] },\n    },\n    encodings: {\n      x: \"x\",\n      y: \"y\",\n      rotate: \"rotate\",\n      fontSize: \"size\",\n      text: \"text\",\n      fill: \"name\",\n    },\n    styles: {\n      textAnchor: \"middle\",\n    },\n  });\n})();\n```\n\n## d3-force\n\n```js | dom\n(async () => {\n  // request data\n  const URLS = [\n    \"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/3df5a34b-9141-453b-b1c9-5dd0eba32273.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/188bb992-7a9b-4e0e-a036-d1d0e4269738.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/61a39597-9564-4f7e-9eb3-3bdd2280061d.json\",\n  ];\n  const [people, questions, schools, relations] = await Promise.all(\n    URLS.map(async (url) => {\n      const response = await fetch(url);\n      return await response.json();\n    })\n  );\n\n  // flatten data to nested data\n  const qidPid = d3.group(\n    relations.filter((d) => d.type === \"1\"),\n    (d) => +d.from\n  );\n  const pidData = d3.group([...people, ...schools], (d) => +d.id);\n  const data = {\n    name: \"永恒的问题\",\n    type: \"问题\",\n    children: questions\n      .filter(({ id }) => qidPid.has(id))\n      .map(({ title, id }) => ({\n        name: title,\n        type: \"问题\",\n        children: Array.from(qidPid.get(id)).map((d) => {\n          const [people] = pidData.get(+d.to);\n          return {\n            name: people.name,\n            type: \"哲学家\",\n          };\n        }),\n      })),\n  };\n\n  // nested data to visual data\n  const root = d3.hierarchy(data);\n  const links = root.links();\n  const nodes = root.descendants();\n  const simulation = d3\n    .forceSimulation(nodes)\n    .force(\n      \"link\",\n      d3\n        .forceLink(links)\n        .id((d) => d.id)\n        .distance(0)\n        .strength(1)\n    )\n    .force(\"charge\", d3.forceManyBody().strength(-50))\n    .force(\"x\", d3.forceX())\n    .force(\"y\", d3.forceY())\n    .stop();\n\n  // @see https://bl.ocks.org/mbostock/1667139\n  // compute a static force layout\n  const n = Math.ceil(\n    Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())\n  );\n  for (let i = 0; i < n; ++i) {\n    simulation.tick();\n  }\n\n  // plot\n  return sp.plot({\n    type: \"layer\",\n    guides: {\n      x: { display: false },\n      y: { display: false },\n    },\n    children: [\n      {\n        type: \"link\",\n        data: links,\n        encodings: {\n          x: (d) => d.source.x,\n          y: (d) => d.source.y,\n          x1: (d) => d.target.x,\n          y1: (d) => d.target.y,\n          stroke: \"#ddd\",\n        },\n      },\n      {\n        type: \"point\",\n        data: nodes,\n        encodings: {\n          x: \"x\",\n          y: \"y\",\n          r: 10,\n          fill: (d) => d.data.type,\n          stroke: (d) => d.data.type,\n        },\n        styles: {\n          fillOpacity: 0.7,\n        },\n      },\n    ],\n  });\n})();\n```\n\n## d3-hierarchy\n\n```js | dom\n(async () => {\n  // request data\n  const URLS = [\n    \"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/188bb992-7a9b-4e0e-a036-d1d0e4269738.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/61a39597-9564-4f7e-9eb3-3bdd2280061d.json\",\n  ];\n  const [people, schools, relations] = await Promise.all(\n    URLS.map(async (url) => {\n      const response = await fetch(url);\n      return await response.json();\n    })\n  );\n\n  // flatten data to nested data\n  const sidPid = d3.group(\n    relations.filter((d) => d.type === \"0\"),\n    (d) => +d.from\n  );\n  const pidData = d3.group(people, (d) => +d.id);\n  const name = (d) => {\n    const { name } = d.data;\n    return name.length > 4 ? name.slice(0, 3) + \"...\" : name;\n  };\n  const data = {\n    name: \"哲学家\",\n    children: schools\n      .filter(({ id }) => sidPid.has(id))\n      .map(({ name, id }) => ({\n        name,\n        children: Array.from(sidPid.get(id)).map((d) => {\n          const [people] = pidData.get(+d.to);\n          return {\n            name: people.name,\n          };\n        }),\n      })),\n  };\n\n  // compute visual data\n  const width = 800;\n  const height = 800;\n  const margin = 5;\n  const padding = 5;\n  const root = d3.hierarchy(data);\n  root.count();\n\n  const descendants = root.descendants();\n  d3\n    .pack()\n    .size([width - margin * 2, height - margin * 2])\n    .padding(padding)(root);\n\n  return sp.plot({\n    type: \"layer\",\n    data: descendants,\n    width,\n    height,\n    guides: {\n      x: { display: false },\n      y: { display: false },\n      color: { display: false },\n    },\n    scales: {\n      r: { type: \"identity\" },\n      x: { domain: [0, width - margin * 2] },\n      y: { domain: [0, height - margin * 2], range: [0, 1] },\n    },\n    encodings: {\n      x: \"x\",\n      y: \"y\",\n    },\n    children: [\n      {\n        type: \"point\",\n        paddingLeft: margin,\n        paddingRight: margin,\n        paddingBottom: margin,\n        paddingTop: margin,\n        encodings: {\n          r: \"r\",\n          stroke: \"height\",\n          fill: \"height\",\n        },\n      },\n      {\n        type: \"text\",\n        transforms: [(data) => data.filter((d) => d.height === 0)],\n        encodings: {\n          text: name,\n        },\n        styles: {\n          textAnchor: \"middle\",\n          dy: \"0.5em\",\n        },\n      },\n    ],\n  });\n})();\n```\n\n## d3-geo\n\n```js | dom\n(async () => {\n  //@see https://observablehq.com/@d3/world-airports?collection=@d3/d3-geo\n\n  const URLS = [\n    \"https://gw.alipayobjects.com/os/bmw-prod/a51018d2-69ef-4e6b-8095-5d4f5815166e.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\",\n    \"https://gw.alipayobjects.com/os/bmw-prod/1070dc04-329e-4655-95b0-f1dc094206b1.json\",\n  ];\n  const [world, people, country] = await Promise.all(\n    URLS.map(async (url) => {\n      const response = await fetch(url);\n      return await response.json();\n    })\n  );\n\n  const projection = d3.geoNaturalEarth1();\n\n  // compute the height\n  const outline = { type: \"Sphere\" };\n  const width = 800;\n  const height = (() => {\n    const [[x0, y0], [x1, y1]] = d3\n      .geoPath(projection.fitWidth(width, outline))\n      .bounds(outline);\n    const dy = Math.ceil(y1 - y0),\n      l = Math.min(Math.ceil(x1 - x0), dy);\n    projection.scale((projection.scale() * (l - 1)) / l).precision(0.2);\n    return dy;\n  })();\n\n  // compute paths data\n  const path = d3.geoPath(projection);\n  const land = topojson.feature(world, world.objects.land);\n  const graticule = d3.geoGraticule10();\n  const paths = [\n    { d: path(land), fill: \"#ddd\", stroke: \"none\" },\n    { d: path(graticule), fill: \"none\", stroke: \"#ddd\" },\n    { d: path(outline), fill: \"none\", stroke: \"black\" },\n  ];\n\n  // compute points data\n  const countryCentroid = new Map(\n    country.features\n      .filter((d) => d.properties.name)\n      .map((d) => [d.properties.name, d.properties.centroid])\n  );\n  const countryName = (d) => (d === \"雅典\" ? \"希腊\" : d);\n  const countries = Array.from(\n    d3.group(people, (d) => d.country),\n    ([country, people]) => {\n      const [x, y] = projection(countryCentroid.get(countryName(country)));\n      return {\n        country,\n        count: people.length,\n        x,\n        y,\n      };\n    }\n  );\n\n  return sp.plot({\n    type: \"layer\",\n    width,\n    height,\n    children: [\n      {\n        type: \"path\",\n        data: paths,\n        scales: {\n          color: { type: \"identity\" },\n        },\n        guides: { color: { display: false } },\n        encodings: {\n          d: \"d\",\n          fill: \"fill\",\n          stroke: \"stroke\",\n        },\n      },\n      {\n        type: \"point\",\n        guides: { x: { display: false }, y: { display: false } },\n        scales: {\n          y: { range: [0, 1], domain: [0, height] },\n          x: { domain: [0, width] },\n          r: { range: [3, 6] },\n        },\n        paddingLeft: 0,\n        paddingTop: 0,\n        paddingBottom: 0,\n        paddingRight: 0,\n        data: countries,\n        encodings: {\n          x: \"x\",\n          y: \"y\",\n          r: \"count\",\n          fill: \"steelblue\",\n          stroke: \"steelblue\",\n        },\n      },\n    ],\n  });\n})();\n```\n"}